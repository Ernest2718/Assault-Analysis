"""
Ernest Lee Mitchell
Wright State University
November 1, MMXXV
"""

"""
Prove Brain Landrum (age 63 at time of assault) fractured tooth of Kender Jones based on field reports from Melissa Jones. If force is greater than 680 N, this shows
Brian Landrum did indeed cause injuries to Kender (age 8 at time of assault).
"""

"""
References:
[1] C. N. Maganaris and J. P. Paul, “in vivo human tendon mechanical properties,” The Journal of Physiology, vol. 521, no. 1, pp. 307-313, Nov. 1999. 
doi:10.1111/j.1469-7793.1999.00307.x

[2]  C.-Y. Sheen, J.-K. Dong, W. A. Brantley, and D. S. Han, “A Study of Fracture Loads and   Fracture Characteristics of Teeth,” 
The Journal of Advanced Prosthodontics, vol. 11, no. 3, pp. 187-192, Jun. 2019. doi:10.4047/jap.2019.11.3.187 

[3] “Effective striking techniques: Throwing powerful strikes for self-defense and Fitness,” California Defense Academy, 
https://cadefenseacademy.com/blog/150275/Effective-Striking-Techniques-Throwing-Powerful-Strikes-for-Self-Defense-and-Fitness#:~:text=To%20throw%20an%20effective%20elbow,bonus%20for%20your%20fitness%20goals! 
(accessed Nov. 1, 2025)

[4] H. Africk, 1.4: Parallel Lines, https://math.libretexts.org/Bookshelves/Geometry/Elementary_College_Geometry_(Africk)/01%3A_Lines_Angles_and_Triangles/1.04%3A_Parallel_Lines 
(accessed Nov. 1, 2025)

[5] K. Kursa et al., (2005). In vivo forces generated by finger flexor muscles do not depend on the rate of fingertip loading during an isometric task. 
Journal of Biomechanics, 38(11), 2288-2293

[6] L. L. Chuang et al., "Quantitative mechanical properties of the relaxed biceps and triceps brachii muscles in patients with subacute stroke: 
A reliability study of the Myoton-3 myometer," BioMed. Eng. Online, vol. 11, no. 1, p. 59, 2012. BioMed. Eng. Online

[7] R. L. Watts and A. W. Wiegner, "Elastic properties of muscles measured at the elbow in man: I. Normal controls," J. Neurol. Neurosurgery. 
Psychiatry, vol. 49, no. 10, pp. 1171-1176, Oct. 1986

[8] S. L. Sherman et al., “Biomechanical analysis of the pectoralis major tendon and comparison of techniques for Tendo-osseous repair,” 
The American Journal of Sports Medicine, vol. 40, no. 8, pp. 1887–1894, Jul. 2012. doi:10.1177/0363546512452849

[9] T. Çevik Saldiran, İ. Kara, and S. K. Yikilmaz, “Quantification of the forearm muscles mechanical properties using Myotonometer: 
Intra- and Inter-Examiner reliability and its relation with hand grip strength,” J. Electromyogr. Kinesiol., vol. 67, p. 102718, Dec. 2022, 
doi: 10.1016/j.jelekin.2022.102718.

[10] “Triangle sum theorem - formula, proof, statement, examples: Angle Sum theorem,” Cuemath, https://www.cuemath.com/geometry/angle-sum-theorem/ 
(accessed Nov. 1, 2025)

[11] V. Tran, L. Podwojewski, S. Le Barbier, H. Pillet, and W. Skalli, 
"Abdominal wall muscle elasticity and abdomen local stiffness on healthy volunteers during various physiological activities," 
J Mech Behav Biomed Mater, vol. 60, pp. 451-459, Jul. 2016, doi: 10.1016/j.jmbbm.2016.03.001

[12] Z. Zhang, W. Wang, F. Li, and J. Guo, "Age and sex-related differences in elastic properties of the gastrocnemius muscle-tendon unit: an observational prospective study," 
Front. Aging, vol. 5, p. 1455404, 2024, doi: 10.3389/fragi.2024.1455404
"""

# Import required libraries.
from datetime import datetime
import matplotlib.pyplot as plt 
#from mpmath import *
import numpy as np
import os
from scipy.integrate import solve_ivp
from scipy.fft import fft, fftfreq, fftshift
from scipy.signal import convolve2d
import sys
from time import perf_counter
import tkinter as tk
import warnings

# I: Load modules in Assault Analysis folder.
# Begin timing of execution of main method.
start_time = perf_counter()

# Get the absolute path of the directory containing Analysis of Incident_0.py
current_dir = os.path.dirname(os.path.abspath(__file__))
# Get the absolute path of the parent directory (project/)
parent_dir = os.path.dirname(current_dir)
# Add the parent directory to sys.path
sys.path.append(parent_dir)

# Import the modules common to Assault Analysis project.
from modules import UStoMetric, Anthropometry, SpringConstant

# Assume the system will have complex eigenvalues and eigenvectors, hence all position
# vectors are in the Complex Number System.
warnings.filterwarnings("ignore", category=np.ComplexWarning)

# II: Define universal constants.
g = 9.81 # Universal gravitational constant on Earth (meter/second-squared)

# III: Biometric data for Analysis.
# Estantiate functions from module library.
converter = UStoMetric.UStoMetricConverter() # Converting measurements from US customary to metric.
male_proportions = Anthropometry.Anthropometric_Data_Male() # Body proportions of males.
female_proportions = Anthropometry.Anthropometric_Data_Female() # Body proportions of females.

# Define moment and distal data of Brian Landrum (child beater, cb).  
weight_cb = 200 # Weight of child beater (pounds-mass).
height_cb = 72 # Height of child beater (inches).
mass_cb = converter.pounds_to_kg(weight_cb) # Mass of child beater (kilogram).
height_cb = 0.01*converter.inches_to_cm(height_cb) # Height of child beater (meter). Note 1 m = 100 cm.
m1 = male_proportions.mass_manual_male(mass_cb) # Mass of child beater's manual (kilogram).
m2 = male_proportions.mass_antebrachial_male(mass_cb) # Mass of child beater's antebrachial (kilogram).
m3 = male_proportions.mass_brachial_male(mass_cb) # Mass of child beater's brachial (kilogram).
L3 = male_proportions.lengthseg_brachial_male(height_cb) # Length of child beater's brachial 
Lg_3= male_proportions.lengthcg_brachial_male(height_cb) # Proximal to distal length to center of mass of brachial of child beater.
J3 = 1/12*m3*L3**2 # Second moment of inertia of child beater's brachial (kg-m^2).

# Muscle and tendon stiffness of child beater's arm. All are measured in Netwons per meter unless otherwise noted.
k_deltoid = 350 # Stiffness of deltoid muscle. https://pmc.ncbi.nlm.nih.gov/articles/PMC2269645/#:~:text=Figure%204.,Tendon%20mechanical%20properties.&text=A%2C%20tendon%20force%2Ddisplacement%20relationship,4A).
k_pm = 221 # Stiffness of pectoralis major muscle. https://profiles.wustl.edu/en/publications/biomechanical-analysis-of-the-pectoralis-major-tendon-and-compari#:~:text=Under%20load%2Dto%2Dfailure%20testing,to%20bone%20is%20reliably%20achieved.
k_triceps = 29.56 # Stiffness of tricep muscle. https://pmc.ncbi.nlm.nih.gov/articles/PMC3350849/#:~:text=The%20SEM%20(SEM%25)%20of,of%20the%20triceps%20brachii%20muscle.
k_biceps = 20.52 # Stiffness of bicep muscle. 
k_abdominal = 2.2 # Stiffness of adominal muscle. https://pubmed.ncbi.nlm.nih.gov/26994992/#:~:text=Then%2C%20during%20the%20Valsalva%20maneuver,for%20investigation%20on%20herniated%20patients.
k_sa = 584.04 # Stiffness of serratus anterior muscle. https://pmc.ncbi.nlm.nih.gov/articles/PMC11586365/#:~:text=Table_title:%20TABLE%203.%20Table_content:%20header:%20%7C%20%7C,%7C%20Older%20women:%20513.67%20%C2%B1%2082.73%20%7C
k_manual = 20 # Stiffness of palmar muscles. https://stacks.cdc.gov/view/cdc/189943/cdc_189943_DS1.pdf#:~:text=The%20most%20reliable%20assessment%20of%20the%20effects,has%20been%20measured%20experimentally%20during%20static%20loading.
k_ercb = 196.6 # Stiffness of extensor carpi radialis brevis muscle. https://www.sciencedirect.com/science/article/pii/S1050641122000918#:~:text=3.1.,and%200.69%E2%80%930.88%20for%20elasticity.
k_fcu = 218.3 # Stiffness of flexor carpi ulnaris muscle. https://www.sciencedirect.com/science/article/pii/S1050641122000918#:~:text=3.1.,and%200.69%E2%80%930.88%20for%20elasticity.
kt_elbow = 1.8 # Torsional stiffness of elbow joint of abuser (Newton*meter/radian). https://pmc.ncbi.nlm.nih.gov/articles/PMC1029052/#:~:text=Abstract,such%20as%20rigidity%20or%20spasticity.

# Acquire total stiffness for each moments in child beater's arm.
# Total stiffness of child beater's manual (hand, parallel). 
k1 = k_manual 
# Total stiffness of child beater's antebrachial (forearm, parallel).
antebrachial_stiffness = [k_ercb, k_fcu]
k_antebrachial = SpringConstant.Spring_Constant_Calculator(antebrachial_stiffness)
k2 = k_antebrachial.parallel_stiffness()
# Total stiffness of child beater's brachial (upper arm, parallel).
brachial_stiffness = [k_triceps, k_biceps]
k_brachial = SpringConstant.Spring_Constant_Calculator(brachial_stiffness)
k3 = k_brachial.parallel_stiffness()
# Total stiffness of child beater's supportiung thoracic muscles.
thoracic_stiffness = [k_pm, k_sa]
k_thoracic = SpringConstant.Spring_Constant_Calculator(thoracic_stiffness)
k_pmandsa = k_thoracic.parallel_stiffness()
# Total stiffness of child beater's supporting structure for arm in vertical (includes shoulder, thoracicr, and abdominal muscles).
vertical_stiffness = [k_deltoid, k_pmandsa, k_abdominal]
k_vertical = SpringConstant.Spring_Constant_Calculator(vertical_stiffness)
k4 = k_vertical.series_stiffness()

# Define moment data of Kender Jones (victim, v).  
weight_v = 57 # Weight of victim (pounds-mass).
mass_v = converter.pounds_to_kg(weight_cb) # Mass of victim (kilogram).
m_head_v = female_proportions.mass_cephalic_female(mass_v) # Approximate mass of victims head in proportion to her total mass (kilogram).

# IV: Define system data of assault.
F_fract = 162 # Fracture load for maxillary central incisor [2].  https://www.tandfonline.com/doi/full/10.1080/03036758.2019.1691612#:~:text=Some%20reports%20state%20a%20wide,2011).
F_0 = m_head_v*g # Amplitude of impulse forcing of victim's head normal to abuser's hand.
t_0 = 1 # Approximate time from engagement to collision of child beater arm motion.
angle_iua = 45 # Inclination angle of child beater's huumerus [3] by triangle sum theorem [9] and parallel lines theorem [4]. 
k_55 = kt_elbow + (k4-k3)*np.cos(2*np.deg2rad(angle_iua)) - m3*g*Lg_3*np.sin(np.deg2rad(angle_iua)) # For value at row 5, column 5 of stiffness matrix K.
omega_freq = 1340 # Resonant frequency to break. https://www.researchgate.net/publication/6216009_Calculation_of_Natural_Frequencies_of_Teeth_Supported_with_the_Periodontal_Ligament

# V: Define matrices for model.
# Moment matrix.
M = np.array([[m1, 0, 0, 0, 0], [0, m2, 0, 0, 0], 
              [0, 0, m3, 0, -m3*Lg_3*np.sin(np.deg2rad(angle_iua))],  
              [0, 0, 0, m3, m3*Lg_3*np.cos(np.deg2rad(angle_iua))], 
              [0, 0, -m3*Lg_3*np.sin(np.deg2rad(angle_iua)), m3*Lg_3*np.cos(np.deg2rad(angle_iua)), J3 + m3*Lg_3**2]])

# Stiffness matrix.
K = np.array([[k1 + k2, -k2, 0, 0, 0], [-k1, k1 + k2, -k3, 0, 0], [0, -k2, k2 + k3, 0, -k3*L3*np.sin(np.deg2rad(angle_iua))],
              [0, 0, 0, k4, k4*L3*np.cos(np.deg2rad(angle_iua))],
              [0, 0, -k3*L3*np.sin(np.deg2rad(angle_iua)), k4*L3*np.cos(np.deg2rad(angle_iua)), k_55]])

# Acquire degree of freedom for model.
num_dof = len(M)

# VI: Perform free vibration analysis (Eigenvalue problem). Assume matrix inv(M)*K is either: nilpotent, has zero, repeat or complex eigenvalues.
# Get schur decomposition of matrix inv(M)*K. Let tolerance be 1e-6.
def custom_schur_decomposition(A, max_iterations=1000, tolerance=1e-6):
    """
    Computes the Schur decomposition of a square matrix A using an iterative QR decomposition algorithm.
    Args:
        A (np.ndarray): The square matrix to decompose.
        max_iterations (int): Maximum number of iterations for the QR algorithm.
        tolerance (float): Tolerance for convergence (checking if off-diagonal elements are close to zero).
    Returns:
        tuple: A tuple containing:
            - T (np.ndarray): The Schur form (quasi-upper triangular or upper triangular for complex).
            - Z (np.ndarray): The unitary matrix of Schur vectors.
    """
    # Verify input matrix is a square matrix.
    n = A.shape[0]
    if n != A.shape[1]:
        raise ValueError("Input matrix must be square.")
    # Initialize complex arrays T and Z.
    T = A.copy().astype(complex)  # Work with complex numbers for generality
    Z = np.eye(n, dtype=complex)
    # Obtain the matrices T and Z.
    for _ in range(max_iterations):
        # Apply QR decomposition algorithm to T.
        Q, R = np.linalg.qr(T)
        # Update T and Z.
        T = R @ Q
        Z = Z @ Q
        # Check for convergence (off-diagonal elements near zero).
        off_diagonal_norm = np.linalg.norm(np.tril(T, k=-1))
        if off_diagonal_norm < tolerance:
            break
    # Return complex matrices T and Z.
    return T, Z

# Acquire eigenvalues and eigenvectors from QR decomposition matrices T and Z.
def get_eigenvectors_from_schur(T, Z):
    """
    Extracts eigenvectors from the Schur form T and Schur vectors Z.
    This is a simplified approach for demonstration and may not handle
    complex eigenvalues or repeated eigenvalues robustly.
    """
    # Shape array of eigenvalues T.   
    n = T.shape[0]
    eigenvalues = np.diag(T)
    # Initalize eigenvector set.
    eigenvectors = []
    # Solve the eigenvector problem.
    for ii in range(n):
        # Constuct eigenvector set from Jordan blocks embedded in input matrix.
        if ii + 1 < n and abs(T[ii+1, ii]) > 1e-6: # Handling Jordan blocks for complex eigenvalues.
            # Obtain the corresponding Schur vectors.
            eigenvectors.append(Z[:, ii])
        else:
            eigenvectors.append(Z[:, ii])
    # Return eigenvalues and eigenvectors.         
    return eigenvalues, np.array(eigenvectors).T  

# Acquire eigenvalues and eigenvectors and sort.
np.seterr(invalid='ignore') # Ignore float point errors.
V, S = custom_schur_decomposition(np.dot(np.linalg.inv(M),K)) # Schurr decomposition of inv(M)*K.
eigenvalues, eigenvectors = get_eigenvectors_from_schur(V, S) # Eigenvalues and associated eigenvectors.
omega_n = np.sqrt(eigenvalues) # Natural frequencies array (radians/second).

# Sort by frequency (complex).
sort_idx = np.argsort(omega_n)
omega_n = omega_n[sort_idx]

# Create sorted array of eigenvalues in diagonal.
eigenvalues = np.diag(omega_n**2)

# Construct modal eigenvector matrix Phi.
Phi = eigenvectors[:, sort_idx]

# Test if eigenvectors spanning vector space that governs Phi are orthonormal weighted by moment matrix M..
def check_weighted_orthonormality(Phi, M, tolerance=1e-6):
    """
    Verifies if a set of modal vectors are orthonormal with respect to a moment matrix M.
    Args:
        Phi (np.ndarray): Matrix of modal vectors (each column is a modal vector).
        M (np.ndarray): Moment matrix.
        tolerance (float): Tolerance for checking near-zero values.

    Returns:
        boolean: True if orthonormal, False otherwise.
        np.ndarray: The result of Phi.T @ M @ Phi.
    """
    # Matrix multiplication of Phi.T, M, and Phi.
    ortho_check = Phi.T @ M @ Phi
    # Define idenity matrix.
    identity_matrix = np.eye(Phi.shape[1])
    # Check if two matrices are idenitical governed by set tolerance.
    is_orthonormal = np.allclose(ortho_check, identity_matrix, atol=tolerance)
    # Return test results.
    return is_orthonormal, ortho_check # Return test results.

# If the test fails, perform the weighted Gram-Schmidt process algorithm until a orthonormal set
# that spans the vectoir space governing all of modal vectors Phi weighted by moment matrix M. 
def weighted_gram_schmidt(Phi_initial, M, max_iterations=1000, tolerance=1e-6):
    """
    Applies a weighted Gram-Schmidt process to a set of vectors
    to achieve orthonormality with respect to a moment matrix M.
    Args:
        Phi_initial (np.ndarray): Initial matrix of vectors (each column is a vector).
        M (np.ndarray): Moment matrix.
        max_iterations (int): Maximum number of iterations for the iterative process.
        tolerance (float): Tolerance for checking near-zero values.
    Returns:
        Psi: The resulting orthonormalized matrix of modal vectors spanning vector space containing Phi.
    """
    # Inititialize orthogonormal modal matrix Psi.
    Psi = Phi_initial.copy()
    num_vectors = Psi.shape[1] # Shape according to number of columns in Phi.

    # Perform the weighted Gram-Schmidt process.
    for iteration in range(max_iterations):
        # Orthogonalization step
        for jj in range(num_vectors):
            # Make current vector orthogonal to all previous vectors.
            for kk in range(jj):
                # Projection of Psi[:, jj] onto Psi[:, kk] with mass weighting.
                projection_coeff = (Psi[:, kk].T @ M @ Psi[:, jj]) / \
                                   (Psi[:, kk].T @ M @ Psi[:, kk])
                Psi[:, jj] -= projection_coeff * Psi[:, kk]
            # Normalization step (weighted by M).
            norm_squared = Psi[:, jj].T @ M @ Psi[:, jj]
            if norm_squared < tolerance:
                # Handle cases where a vector might become numerically zero.
                print(f"Warning: Vector {jj} became numerically zero during Gram-Schmidt. "
                      "Consider checking linear independence of initial vectors.")
            else:
                # Output set of modal vectors Psi.
                Psi[:, jj] /= np.sqrt(norm_squared)
        # Check for orthonormality after each iteration.
        is_orthonormal, result_matrix = check_weighted_orthonormality(Psi, M, tolerance)
        if is_orthonormal:
            # Test passes. Return Psi.
            print(f"Weighted orthonormalization achieved in {iteration + 1} iterations.")
            return Psi
    # Otherwise if newly generated set in Psi is still not orthonormal that spans V containing Phi. Repeat process. 
    print(f"Warning: Weighted orthonormalization not achieved within {max_iterations} iterations.")
    # Obtain the orthonormalized modal matrix Psi.
    return Psi

# Construct the orthonormalized modal matrix Psi.
Psi = weighted_gram_schmidt(Phi, M)
Psi_trans = Psi.T # Hermitian (complex transpose) of Psi. 

# VII: Forcing vector function.
# Define the impulse forcing at collision time t_0. Via the Dirac-delta Function.
def dirac_delta_approx(t, t_0, epsilon):
    """
    Approximates the Dirac delta function using a Gaussian function.
    Arg:
        t: array of time values.
        t0: the point where the impulse (collision) occurs.
        epsilon: width of the pulse (governs the approximation's sharpness).
    Returns:
        Impulse function.
    """
    # Return array values for a given time internal t about time of collision t_0 for 
    # Pulse width epsilon.
    #return np.where(np.abs(t - t_0) <= epsilon / 2, 1 / epsilon, 0)
    return (1 / (np.sqrt(2 * np.pi * epsilon**2))) * np.exp(-(t - t_0)**2 / (2 * epsilon**2))

# Generate modal Forcing Function G.
# The Dirac-delta function is applied to the first degree of freedom at time of collision t = t_0.
def forcing_function(t):
    """
    Generates modal forcing function with original forcing function F given
    a modal matrix Psi (assumed orthoormal).
    Arg
        t: array of time values.
    Returns:
        G(t) = Psi.T*F(t) (modal force vector)
    """
    F = np.zeros(num_dof) # Initialize forcing function.
    # Construct forcing vector (Newtons). Note in F[4], moment forcing is in Newton-meter.
    # F[0] - Forcing for coordinate x_1, horizontal position of abuser's manual.
    # F[1] - Forcing for coordinate x_2, horizontal position of abuser's antebrachial.
    # F[2] - Forcing for coordinate x_3, horizontal position of abuser's brachial.
    # F[3] - Forcing for coordinate y_3, vertical position of abuser's brachial.
    # F[4] - Moment forcing for angular displacement of abuser's elbow joint. 
    F[0] = F_0 * dirac_delta_approx(t, 1, 1) # t_0 is the value at t = 1 seconds.
    F[1] = 0
    F[2] = -k3*L3*np.cos(np.deg2rad(angle_iua))
    F[3] = -m3*g - k4*L3*np.sin(np.deg2rad(angle_iua))
    F[4] = (1/2*(k3 - k4)*np.sin(2*np.deg2rad(angle_iua))*L3**2) - m3*g*Lg_3*np.cos(np.deg2rad(angle_iua)) - kt_elbow*np.deg2rad(np.deg2rad(angle_iua)) 
    # Compute modal forcing vector G.
    G = Psi_trans @ F # Modal forcing function.
    # Return modal force array G.
    return G
 
# VIII: Solve the uncoupled system.
# Function for the first-order modal ODE system. 
def system_eom(t, y):
    # y is the modal state vector [p, q] = [p1, p2, p3, p4, p5, q1, q2, q3, q4, q5]. 
    x = y[:num_dof] # Modal displacement vector p.
    v = y[num_dof:] # Modal velocity vector q.
    # Ascertain modal acceleration: a = G - eigenvalues * x.
    accelerations = np.dot(np.linalg.inv(np.eye(num_dof)), (forcing_function(t) - np.dot(eigenvalues, x)))
    # Return the derivatives [q1, q2, q3, q4, q5, a1, a2, a3, a4, a5].
    return np.hstack((v, accelerations))

# Initial Conditions at t = 0 seconds.
# Assume zero initial displacement and velocity.
x0 = np.zeros(num_dof) # Initial modal displacement vector.
v0 = np.zeros(num_dof) # Initial modal velocity vector.
y0 = np.hstack((x0, v0)) # Initial state vector.

# Time points for simulation.
t_span = (0, 1) # Simulate from t = 0 to t = 1 seconds. 
t_eval = np.linspace(t_span[0], t_span[1], 1000)

# Solve the uncoupled system of modal ODEs.
solution = solve_ivp(system_eom, t_span, y0, t_eval=t_eval, rtol=1e-5, atol=1e-6)

# Extract results.
time = solution.t

# IX: Incident analysis.
# Magnitude of displacements vectors.
# Displacement vector is u(t) = [x_1, x_2, x_3, y_3, theta_3].
# Velocity vector is u'(t) = [vx_1, vx_2, vx_3, vy_3, omega_3].
modal_disp = solution.y[:num_dof, :].T
displacements =  modal_disp @ Psi
displacements_mag = abs(displacements) # Modulus of displacement vector u = abs(Psi*x).
modal_vel = solution.y[num_dof:, :].T
velocities = modal_vel @ Psi
velocities_mag = abs(velocities) # Modulus of displacement vector u' = abs(Psi*v).

# Extract real and imaginary parts for plotting
# 1. Define the circle (e.g., unit circle for reference)
theta = np.linspace(0, 2 * np.pi, 100)
circle_x = np.cos(theta)
circle_y = np.sin(theta)

displacements_vectors_real = np.real(displacements)
displacements_vectors_imag = np.imag(displacements)

# 3. Create the plot
fig, ax = plt.subplots(figsize=(7, 7))

# Plot the circle
ax.plot(circle_x, circle_y, 'k--', label='Unit Circle')

# Plot the modal vectors using quiver
# The 'quiver' function takes (origin_x, origin_y, vector_x_component, vector_y_component)
ax.quiver(
    np.zeros_like(displacements_vectors_real),  # Origin x-coordinates (all at 0)
    np.zeros_like(displacements_vectors_imag),  # Origin y-coordinates (all at 0)
    displacements_vectors_real,                 # Vector x-components
    displacements_vectors_imag,                 # Vector y-components
    angles='xy', scale_units='xy', scale=0.1, color='b', label='Modal Vectors'
)

# Customize the plot
ax.set_aspect('equal', adjustable='box')  # Ensure circular aspect ratio
ax.set_xlabel('Real Part')
ax.set_ylabel('Imaginary Part')
ax.set_title('Circle Plot of Modal Vectors (Complex Plane)')
ax.grid(True)
ax.axhline(0, color='cyan', linewidth=0.5)
ax.axvline(0, color='cyan', linewidth=0.5)
ax.legend()
# Show the plot
plt.show()

# Plot the modal positions. 
# Abuser's hand displacement.
plt.figure(figsize=(10, 6))
plt.plot(time, displacements_mag[:, 0], color = 'red')
plt.title('Plot for x1')
plt.xlabel('Time (second)')
plt.ylabel('Hand Position (meter)')
plt.grid(True)
plt.show()

# Abuser's forearm displacement.
plt.figure(figsize=(10, 6))
plt.plot(time, displacements_mag[:, 1], color = 'blue')
plt.title('Plot for x2')
plt.xlabel('Time (second)')
plt.ylabel('Forearm Position (meter)')
plt.grid(True)
plt.show()

# Abuser's upper arm horizontal displacement.
plt.figure(figsize=(10, 6))
plt.plot(time, displacements_mag[:, 2], color = 'green')
plt.title('Plot for x3')
plt.xlabel('Time (second)')
plt.ylabel('Upper Arm Horizontal (meter)')
plt.grid(True)
plt.show()

# Abuser's upper arm vertical displacement.
plt.figure(figsize=(10, 6))
plt.plot(time, displacements_mag[:, 3], color = 'yellow')
plt.title('Plot for y3')
plt.xlabel('Time (second)')
plt.ylabel('Upper Arm Vertical (meter)')
plt.grid(True)
plt.show()

# Abuser's elbow angular displacement.
plt.figure(figsize=(10, 6))
plt.plot(time, np.rad2deg(displacements_mag[:, 4]), color = 'black')
plt.title('Plot for \u03B8')
plt.xlabel('Time (second)')
plt.ylabel('Elbow Flexion (degrees)')
plt.grid(True)
plt.show()

# X: Blooms tax.
# Find the maximum accelerations at time of collision t = t_0. 
# Note: for position 5, ascertain angular velocity of elbow flexion.
a_manual = np.max(velocities_mag[:,0])/np.max(t_span)
a_antebrachial = np.max(velocities_mag[:,1])/np.max(t_span)
a_brachial_hor = np.max(velocities_mag[:,2])/np.max(t_span)
a_brachial_ver = np.max(velocities_mag[:,3])/np.max(t_span)
angveloc_elbow = np.max(velocities_mag[:,4])

# Compute force applied to victim's tooth at point of contact. 
F_manual = m1*a_manual
F_antebrachial = m2*a_antebrachial
F_brachial = m3*np.sqrt((a_brachial_hor**2) + (a_brachial_ver**2))
F_elbow = (J3*angveloc_elbow**2)/(L3-Lg_3)
F_total = F_manual + F_antebrachial + F_brachial + F_elbow

# Ascertain if the child beater broke the victim's tooth
if F_total >= F_fract:
    print(f"The force that child beater Brian Landrum''S arm applied to victim Kender Jones''s tooth is {F_total:.1f} Newtons.")
    print("Brian Landrum did fracture Kender Jones''s tooth.")
else:
    print("Inconclusive.")

# Total time to run main method.
end_time = perf_counter()
print(f"Elapsed time during the whole program is {end_time - start_time:.1f} seconds.")
